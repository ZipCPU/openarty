////////////////////////////////////////////////////////////////////////////////
//
// Filename:	./toplevel.v
// {{{
// Project:	OpenArty, an entirely open SoC based upon the Arty platform
//
// DO NOT EDIT THIS FILE!
// Computer Generated: This file is computer generated by AUTOFPGA. DO NOT EDIT.
// DO NOT EDIT THIS FILE!
//
// CmdLine:	autofpga -d -o . allclocks.txt global.txt icape.txt version.txt buserr.txt pic.txt pwrcount.txt spio.txt clrspio.txt rtcgps.txt rtcdate.txt wbuconsole.txt bkram.txt spansion.txt sdram.txt zipmaster.txt mdio.txt enet.txt gps.txt sdspi.txt mem_full.txt mem_bkram_only.txt mem_sdram_bkram.txt
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
// }}}
// Copyright (C) 2017-2024, Gisselquist Technology, LLC
// {{{
// This file is part of the OpenArty project.
//
// The OpenArty project is free software and gateware, licensed under the
// terms of the 3rd version of the GNU General Public License as published by
// the Free Software Foundation.
//
// This project is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// <http://www.gnu.org/licenses/> for a copy.
// }}}
// License:	GPL, v3, as defined and found on www.gnu.org,
// {{{
//		http://www.gnu.org/licenses/gpl.html
//
////////////////////////////////////////////////////////////////////////////////
//
// }}}
`default_nettype	none


//
// Here we declare our toplevel.v (toplevel) design module.
// All design logic must take place beneath this top level.
//
// The port declarations just copy data from the @TOP.PORTLIST
// key, or equivalently from the @MAIN.PORTLIST key if
// @TOP.PORTLIST is absent.  For those peripherals that don't need
// any top level logic, the @MAIN.PORTLIST should be sufficent,
// so the @TOP.PORTLIST key may be left undefined.
//
// The only exception is that any clocks with CLOCK.TOP tags will
// also appear in this list
//
module	toplevel(sys_clk_i,
		// SD Card
		o_sd_sck, io_sd_cmd, io_sd, i_sd_cd,
		// SPIO interface
		i_sw, i_btn, o_led,
		// Ethernet control (packets) lines
		// i_eth_tx_clk and i_eth_rx_clk come from allclocks.txt
		o_eth_rstn, i_eth_col, i_eth_crs, i_eth_rx_dv,
			i_eth_rxd, i_eth_rxerr,
		o_eth_tx_en, o_eth_txd,
		// CLRLED interface
		o_clr_ledr, o_clr_ledg, o_clr_ledb,
		no_clk,
		// Top level Quad-SPI I/O ports
		o_qspi_cs_n, o_qspi_sck, io_qspi_dat,
		i_eth_tx_clk,
		i_eth_rx_clk,
		// In support of all clocks
		i_reset_btn, o_eth_ref_clk,
		// UART/host to wishbone interface
		i_wbu_uart_rx, o_wbu_uart_tx,
		// SDRAM I/O port wires
		ddr3_reset_n, ddr3_cke, ddr3_ck_p, ddr3_ck_n,
		ddr3_cs_n, ddr3_ras_n, ddr3_cas_n, ddr3_we_n,
		ddr3_dqs_p, ddr3_dqs_n,
		ddr3_addr, ddr3_ba,
		ddr3_dq, ddr3_dm, ddr3_odt,
		// The GPS-UART
		i_gpsu_rx, o_gpsu_tx,
		// The GPS 1PPS signal port
		i_gps_pps,
		// Toplevel ethernet MDIO ports
		o_eth_mdclk, io_eth_mdio);
	//
	// Declaring any top level parameters.
	//
	// These declarations just copy data from the @TOP.PARAM key,
	// or from the @MAIN.PARAM key if @TOP.PARAM is absent.  For
	// those peripherals that don't do anything at the top level,
	// the @MAIN.PARAM key should be sufficient, so the @TOP.PARAM
	// key may be left undefined.
	//
	localparam	ICAPE_LGDIV=3;
	////////////////////////////////////////////////////////////////////////
	//
	// Variables/definitions/parameters used by the ZipCPU bus master
	// {{{
	//
	// A 32-bit address indicating where the ZipCPU should start running
	// from
`ifdef	BKROM_ACCESS
	localparam	RESET_ADDRESS = @$(/bkrom.BASE);
`else
`ifdef	FLASH_ACCESS
	localparam	RESET_ADDRESS = 182452224;
`else
	localparam	RESET_ADDRESS = 150994944;
`endif	// FLASH_ACCESS
`endif	// BKROM_ACCESS
	//
	// The number of valid bits on the bus
	localparam	ZIP_ADDRESS_WIDTH = 27; // Zip-CPU address width
	//
	// Number of ZipCPU interrupts
	localparam	ZIP_INTS = 16;
	//
	// ZIP_START_HALTED
	//
	// A boolean, indicating whether or not the ZipCPU be halted on startup?
`ifdef	BKROM_ACCESS
	localparam	ZIP_START_HALTED=1'b0;
`else
	localparam	ZIP_START_HALTED=1'b1;
`endif
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS parameters
	// {{{
	// Baudrate :   1000000
	// Clock    :  82500000
	localparam [23:0] BUSUART = 24'h52;	//   1000000 baud
	localparam	DBGBUSBITS = $clog2(BUSUART);
	//
	// Maximum command is 6 bytes, where each byte takes 10 baud clocks
	// and each baud clock requires DBGBUSBITS to represent.  Here,
	// we'll add one more for good measure.
	localparam	DBGBUSWATCHDOG_RAW = DBGBUSBITS + 9;
	localparam	DBGBUSWATCHDOG = (DBGBUSWATCHDOG_RAW > 19)
				? DBGBUSWATCHDOG_RAW : 19;
	// }}}
	localparam [31:0] GPSCLOCK_DEFAULT_STEP = 32'had03da79;
	//
	// Declaring our input and output ports.  We listed these above,
	// now we are declaring them here.
	//
	// These declarations just copy data from the @TOP.IODECLS key,
	// or from the @MAIN.IODECL key if @TOP.IODECL is absent.  For
	// those peripherals that don't do anything at the top level,
	// the @MAIN.IODECL key should be sufficient, so the @TOP.IODECL
	// key may be left undefined.
	//
	// We start with any @CLOCK.TOP keys
	//
	input	wire		sys_clk_i;
	// SD Card
	// {{{
	output	wire		o_sd_sck;
	inout	wire		io_sd_cmd;
	inout	wire	[3:0]	io_sd;
	input	wire		i_sd_cd;
	// }}}
	// SPIO interface
	input	wire	[4-1:0]	i_sw;
	input	wire	[4-1:0]	i_btn;
	output	wire	[4-1:0]	o_led;
	// Ethernet control
	output	wire		o_eth_rstn;
	input	wire		i_eth_col, i_eth_crs, i_eth_rx_dv;
	input	wire	[3:0]	i_eth_rxd;
	input	wire		i_eth_rxerr;
	output	wire		o_eth_tx_en;
	output	wire	[3:0]	o_eth_txd;
	// SPIO interface
	output	wire	[3:0]	o_clr_ledr, o_clr_ledg, o_clr_ledb;
	// This clock is unused in main, AutoFPGA still wants it though
	// Verilator lint_off UNUSED
	input	wire	no_clk;
	// Verilator lint_on  UNUSED
	// Quad SPI flash
	output	wire		o_qspi_cs_n;
	output	wire		o_qspi_sck;
	inout	wire	[3:0]	io_qspi_dat;
	// With no ethernet included, this clock will be unused
	// Verilator lint_off UNUSED
	input	wire	i_eth_tx_clk;
	// Verilator lint_on  UNUSED
	// With no ethernet included, this clock will be unused
	// Verilator lint_off UNUSED
	input	wire	i_eth_rx_clk;
	// Verilator lint_on  UNUSED
	input	wire	i_reset_btn;
	output	wire	o_eth_ref_clk;
	input	wire		i_wbu_uart_rx;
	output	wire		o_wbu_uart_tx;
	// I/O declarations for the DDR3 SDRAM
	output	wire		ddr3_reset_n;
	output	wire	[0:0]	ddr3_cke;
	output	wire	[0:0]	ddr3_ck_p, ddr3_ck_n;
	output	wire	[0:0]	ddr3_cs_n;
	output	wire		ddr3_ras_n, ddr3_cas_n, ddr3_we_n;
	output	wire	[2:0]	ddr3_ba;
	output	wire	[13:0]	ddr3_addr;
	output	wire	[0:0]	ddr3_odt;
	output	wire	[1:0]	ddr3_dm;
	inout	wire	[1:0]	ddr3_dqs_p, ddr3_dqs_n;
	inout	wire	[15:0]	ddr3_dq;

	input	wire		i_gpsu_rx;
	output	wire		o_gpsu_tx;
	//The GPS Clock
	input	wire		i_gps_pps;
	// Ethernet control (MDIO)
	output	wire		o_eth_mdclk;
	inout	wire		io_eth_mdio;


	//
	// Declaring component data, internal wires and registers
	//
	// These declarations just copy data from the @TOP.DEFNS key
	// within the component data files.
	//
	// SD Card definitions
	// {{{
	wire		w_sdcard_cmd;
	wire	[3:0]	w_sdcard_data;

	wire		i_sd_cmd;
	wire	[3:0]	i_sd;
	// }}}
	wire		w_qspi_sck, w_qspi_cs_n;
	wire	[1:0]	qspi_bmod;
	wire	[3:0]	qspi_dat;
	wire	[3:0]	i_qspi_dat, i_qspi_pedge, i_qspi_nedge;
	// Verilator lint_off UNUSED
	wire		ign_cpu_stall, ign_cpu_ack;
	wire	[31:0]	ign_cpu_idata;
`ifdef	VERILATOR
	wire		ign_cpu_prof_stb;
	wire	[27+$clog2(32/8)-1:0] ign_cpu_prof_addr;
	wire [31:0]	ign_cpu_prof_ticks;
`endif
	// Verilator lint_on  UNUSED
	wire	s_clk, s_reset;
	wire	eth_rx_clk, eth_tx_clk;
	// Wires necessary to run the SDRAM
	//
	wire	sdram_cyc, sdram_stb, sdram_we,
		sdram_stall, sdram_ack, sdram_err;
	wire	[(27-1):0]	sdram_addr;
	wire	[(32-1):0]	sdram_wdata,
					sdram_rdata;
	wire	[(32/8-1):0]	sdram_sel;

	// Ethernet control (MDIO)
	wire		w_mdio, w_mdwe;


	//
	// Time to call the main module within main.v.  Remember, the purpose
	// of the main.v module is to contain all of our portable logic.
	// Things that are Xilinx (or even Altera) specific, or for that
	// matter anything that requires something other than on-off logic,
	// such as the high impedence states required by many wires, is
	// kept in this (toplevel.v) module.  Everything else goes in
	// main.v.
	//
	// We automatically place s_clk, and s_reset here.  You may need
	// to define those above.  (You did, didn't you?)  Other
	// component descriptions come from the keys @TOP.MAIN (if it
	// exists), or @MAIN.PORTLIST if it does not.
	//

	main	thedesign(s_clk, s_reset,
		// SD Card
		o_sd_sck, w_sd_cmd, w_sd_data,
		io_sd_cmd, io_sd, i_sd_cd,
		// SPIO interface
		i_sw, i_btn, o_led,
		// Ethernet control (packets) lines
		// i_eth_tx_clk and i_eth_rx_clk come from allclocks.txt
		o_eth_rstn, i_eth_col, i_eth_crs, i_eth_rx_dv,
			i_eth_rxd, i_eth_rxerr,
		o_eth_tx_en, o_eth_txd,
		// CLRLED interface
		o_clr_ledr, o_clr_ledg, o_clr_ledb,
		sys_clk_i,
		// Quad SPI flash
		w_qspi_cs_n, w_qspi_sck, qspi_dat, i_qspi_dat, qspi_bmod,
		eth_tx_clk,
		// (Unused) ZipCPU Simulation port
		1'b0, 1'b0, 1'b0, 7'h0, 32'h0,
		ign_cpu_stall, ign_cpu_ack, ign_cpu_idata,
`ifdef	VERILATOR
		ign_cpu_prof_stb, ign_cpu_prof_addr, ign_cpu_prof_ticks,
`endif
		// ZipCPU reset port
		s_reset,
		eth_rx_clk,
		// UART/host to wishbone interface
		i_wbu_uart_rx, o_wbu_uart_tx,
		// The SDRAM interface to an toplevel AXI4 module
		//
		sdram_cyc, sdram_stb, sdram_we,
			sdram_addr, sdram_wdata, sdram_sel,
			sdram_stall, sdram_ack, sdram_rdata,
			sdram_err,
		// The GPS-UART
		i_gpsu_rx, o_gpsu_tx,
		// The GPS 1PPS signal port
		i_gps_pps,
		o_eth_mdclk, w_mdio, w_mdwe, io_eth_mdio);


	//
	// Our final section to the toplevel is used to provide all of
	// that special logic that couldnt fit in main.  This logic is
	// given by the @TOP.INSERT tag in our data files.
	//


	//////////////////////////////////////////////////////////////////////
	//
	// SD Card SPI Controller
	// {{{
	//////////////////////////////////////////////////////////////////////
	//
	//

	// Wires for setting up the SD Card Controller
	// {{{
	// This is how we'd set up for SDIO
	// assign io_sdcard_cmd = w_sdcard_cmd ? 1'bz:1'b0;	// MOSI
	// assign io_sdcard[0] = w_sdcard_data[0]? 1'bz:1'b0;	// MISO
	// assign io_sdcard[1] = w_sdcard_data[1]? 1'bz:1'b0;
	// assign io_sdcard[2] = w_sdcard_data[2]? 1'bz:1'b0;
	// assign io_sdcard[3] = w_sdcard_data[3]? 1'bz:1'b0;	// CS_n
	// }}}
	IOBUF sdcard_cmd_bf(.T(1'b0),.O(i_sd_cmd),.I(w_sdcard_cmd),.IO(io_sd_cmd));// MISO
	IOBUF sdcard_dat0_bf(.T(1'b1),.O(i_sd[0]),.I(1'b1),.IO(io_sd[0]));// MISO
	IOBUF sdcard_dat1_bf(.T(1'b1),.O(i_sd[1]),.I(1'b1),.IO(io_sd[1]));
	IOBUF sdcard_dat2_bf(.T(1'b1),.O(i_sd[2]),.I(1'b1),.IO(io_sd[2]));

	// Implement an open-drain output
	IOBUF sdcard_dat3_bf(.T(w_sdcard_data[3]),.O(i_sd[3]),.I(1'b0),.IO(io_sd[3]));
	// }}}

	//
	//
	// Wires for setting up the QSPI flash wishbone peripheral
	//
	//
	// QSPI)BMOD, Quad SPI bus mode, Bus modes are:
	//	0?	Normal serial mode, one bit in one bit out
	//	10	Quad SPI mode, going out
	//	11	Quad SPI mode coming from the device (read mode)
	xoddr   xqspi_sck( s_clk, { 1'b1, !w_qspi_sck }, o_qspi_sck);
	xoddr   xqspi_csn( s_clk, { w_qspi_cs_n, w_qspi_cs_n },o_qspi_cs_n);
	//
	xioddr  xqspi_d0(  s_clk, (qspi_bmod != 2'b11), { (2){qspi_dat[0]}},
		{ i_qspi_pedge[0], i_qspi_nedge[0] }, io_qspi_dat[0]);
	xioddr  xqspi_d1(  s_clk, (qspi_bmod == 2'b10), { (2){qspi_dat[1]}},
		{ i_qspi_pedge[1], i_qspi_nedge[1] }, io_qspi_dat[1]);
	xioddr  xqspi_d2(  s_clk, (qspi_bmod != 2'b11),
		qspi_bmod[1] ? { (2){qspi_dat[2]}} : 2'b11,
		{ i_qspi_pedge[2], i_qspi_nedge[2] }, io_qspi_dat[2]);
	xioddr  xqspi_d3(  s_clk, (qspi_bmod != 2'b11),
		qspi_bmod[1] ? { (2){qspi_dat[3]}} : 2'b11,
		{ i_qspi_pedge[3], i_qspi_nedge[3] }, io_qspi_dat[3]);

	assign	i_qspi_dat = i_qspi_pedge;

`ifdef VERILATOR
	assign	s_clk = sys_clk_i;

	assign	eth_tx_clk = i_eth_tx_clk;
	assign	eth_rx_clk = i_eth_rx_clk;

`else
	reg	[7:0]	pre_reset;
	reg		pwr_reset;

	// Since all our stuff is synchronous to the clock that comes out of
	// the memory controller, sys_reset must needs come out of the memory
	// controller.
	//
	// Logic description starts with the PRE-reset, so as to make certain
	// we include the reset button.
	//
	initial	pre_reset = -1;
	always @(posedge sys_clk)
		pre_reset <= ((!i_reset_btn)||(clk_locked))
			? -1 : { pre_reset, 1'b0 };
	//
	// and then continues with the actual reset, now that we've
	// synchronized our reset button wire.  This is an active LOW reset.
	initial	pwr_reset = 1'b1;
	always @(posedge sys_clk)
		pwr_reset <= pre_reset[7];
`ifdef	VERILATOR
	assign	s_reset = pwr_reset;
`endif

	//
	// Of course, this only goes into the memory controller.  The true
	// device reset comes out of that memory controller, synchronized to our
	// memory generator provided clock(s)

	// Build our master clock
	wire	sys_clk, mem_clk_200mhz,
		clk1_unused, clk2_unused, enet_clk, clk4_unused,
		clk5_unused, clk_feedback, clk_locked, mem_clk_200mhz_nobuf,
		mem_clk_nobuf, clk_feedback_bufd;
	PLLE2_BASE #(
		.BANDWIDTH("OPTIMIZED"), // OPTIMIZED, HIGH, LOW
		.CLKFBOUT_PHASE(0.0),   // Phase offset in degrees of CLKFB, (-360-360)
		.CLKIN1_PERIOD(10.0),   // Input clock period in ns resolution
		// CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: divide amount for each CLKOUT(1-128)
		.CLKFBOUT_MULT(8),      // Multiply value for all CLKOUT (2-64)
		.CLKOUT0_DIVIDE(8),     // 100 MHz      (Clock for MIG)
		.CLKOUT1_DIVIDE(4),     // 200 MHz      (MIG Reference clock)
		.CLKOUT2_DIVIDE(16),    //  50 MHz      (Unused)
		.CLKOUT3_DIVIDE(32),    //  25 MHz      (Ethernet reference clk)
		.CLKOUT4_DIVIDE(32),    //  50 MHz      (Unused clock?)
		.CLKOUT5_DIVIDE(24),    //  66 MHz
		// CLKOUT0_DUTY_CYCLE -- Duty cycle for each CLKOUT
		.CLKOUT0_DUTY_CYCLE(0.5),
		.CLKOUT1_DUTY_CYCLE(0.5),
		.CLKOUT2_DUTY_CYCLE(0.5),
		.CLKOUT3_DUTY_CYCLE(0.5),
		.CLKOUT4_DUTY_CYCLE(0.5),
		.CLKOUT5_DUTY_CYCLE(0.5),
		// CLKOUT0_PHASE -- phase offset for each CLKOUT
		.CLKOUT0_PHASE(0.0),
		.CLKOUT1_PHASE(0.0),
		.CLKOUT2_PHASE(0.0),
		.CLKOUT3_PHASE(0.0),
		.CLKOUT4_PHASE(0.0),
		.CLKOUT5_PHASE(0.0),
		.DIVCLK_DIVIDE(1),      // Master division value , (1-56)
		.STARTUP_WAIT("TRUE")   // Delay DONE until PLL Locks, ("TRUE"/"FALSE")
	) genclock(
		// Clock outputs: 1-bit (each) output
		.CLKOUT0(mem_clk_nobuf),
		.CLKOUT1(mem_clk_200mhz_nobuf),
		.CLKOUT2(clk2_unused),
		.CLKOUT3(enet_clk),
		.CLKOUT4(clk4_unused),
		.CLKOUT5(clk5_unused),
		.CLKFBOUT(clk_feedback), // 1-bit output, feedback clock
		.LOCKED(clk_locked),
		.CLKIN1(sys_clk),
		.PWRDWN(1'b0),
		.RST(1'b0),
		.CLKFBIN(clk_feedback_bufd) // 1-bit input, feedback clock
	);

	BUFH	feedback_buffer(.I(clk_feedback),.O(clk_feedback_bufd));
	// BUFG memref_buffer(.I(mem_clk_200mhz_nobuf),.O(mem_clk_200mhz));
	IBUF	sysclk_buf(.I(sys_clk_i), .O(sys_clk));

	BUFG	eth_rx(.I(i_eth_rx_clk), .O(eth_rx_clk));
	BUFG	eth_tx(.I(i_eth_tx_clk), .O(eth_tx_clk));

	assign	o_eth_ref_clk = enet_clk;
`endif

	wire	[31:0]	sdram_debug;

	migsdram #(.AXIDWIDTH(1), .WBDATAWIDTH(32),
			.DDRWIDTH(16),
			.RAMABITS(28))
	sdrami(
		.i_clk(mem_clk_nobuf),
		.i_clk_200mhz(mem_clk_200mhz_nobuf),
		.o_sys_clk(s_clk),
		.i_rst(pwr_reset),
		.o_sys_reset(s_reset),
		//
		.i_wb_cyc(sdram_cyc), .i_wb_stb(sdram_stb),
		.i_wb_we(sdram_we), .i_wb_addr(sdram_addr),
			.i_wb_data(sdram_wdata), .i_wb_sel(sdram_sel),
		.o_wb_stall(sdram_stall),    .o_wb_ack(sdram_ack),
			.o_wb_data(sdram_rdata), .o_wb_err(sdram_err),
		//
		.o_ddr_ck_p(ddr3_ck_p), .o_ddr_ck_n(ddr3_ck_n),
		.o_ddr_reset_n(ddr3_reset_n), .o_ddr_cke(ddr3_cke),
		.o_ddr_cs_n(ddr3_cs_n), .o_ddr_ras_n(ddr3_ras_n),
		.o_ddr_cas_n(ddr3_cas_n), .o_ddr_we_n(ddr3_we_n),
		.o_ddr_ba(ddr3_ba), .o_ddr_addr(ddr3_addr),
		.o_ddr_odt(ddr3_odt), .o_ddr_dm(ddr3_dm),
		.io_ddr_dqs_p(ddr3_dqs_p), .io_ddr_dqs_n(ddr3_dqs_n),
		.io_ddr_data(ddr3_dq)
		);
 

	assign	io_eth_mdio = (w_mdwe)?w_mdio : 1'bz;



endmodule // end of toplevel.v module definition
